// Copyright 2015 Andre Pool
// Licensed under the Apache License version 2.0
// You may not use this file except in compliance with this License
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

#include <stdio.h>
#include "adc.h"
#include "communication.h"
#include "global.h"
#include "safety.h"
#include "pid.h"
#include "pwm.h"

static uint16_t error = 0; // TODO SAFETY_ERROR_INIT_NOT_PERFORMED;
static safetyT safety;
static bool measureCurrentA = false;
static bool measureBoardTemperature = false;
static uint16_t motorTimeoutValue = 0;
static uint16_t lastValidPacketAge = 0;
static uint8_t adcCalibrationCounter = 0;
static angleTachoT angleTachoZero;
static bool angleTachoInitialized = false;
static uint32_t tachoSum = 0;
static uint32_t angleSum = 0;

// keep the adc value storage very fast to prevent jitter when activated when scheduler is active.
static void adcHandler(ADC_t *adc, uint8_t ch_mask, adc_result_t result) {
	switch (ch_mask) {
	case ADC_CH0:
		safety.tacho = result;
		break;

	case ADC_CH1:
		safety.angle = result;
         break;

	case ADC_CH2:
		// use virtual channel 2 to measure current of return path bridge A and bridge B
		if( measureCurrentA ) {
			safety.currentA = result;
			// TODO: figure out for all changes why the MUXCTLR needs to programmed they other way around
			// when measuring A, i would expect preparing for B, but that is not the case
			ADCA.CH2.MUXCTRL = ADCCH_POS_PIN2 << ADC_CH_MUXPOS_gp; // prepare for bridge A (PA2)
		} else {
			safety.currentB = result;
			ADCA.CH2.MUXCTRL = ADCCH_POS_PIN3 << ADC_CH_MUXPOS_gp; // prepare for bridge B (PA3)
		}
		measureCurrentA = ! measureCurrentA; // toggle every time between A and B
		break;
	case ADC_CH3:
		// the last virtual channel is shared between board voltage (PA4) and on board temperature (PA5)
		if( measureBoardTemperature ) {
			safety.boardTemp = result;
 			ADCA.CH3.MUXCTRL = ADCCH_POS_PIN5 << ADC_CH_MUXPOS_gp; // prepare for board temperature (PA5)
		} else {
			safety.boardVoltage = result;
			ADCA.CH3.MUXCTRL = ADCCH_POS_PIN4 << ADC_CH_MUXPOS_gp; // prepare for board voltage (PA4)
		}
		measureBoardTemperature = ! measureBoardTemperature;
		break;
	default:
		break;
     }
 }

// setup the rather "complicated" adc converter
// based on http://asf.atmel.com/docs/3.0.1/xmegaa/html/adc_use_case_1.html
static void adcInit(void) {
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&ADCA, &adc_conf);
	adcch_read_configuration(&ADCA, ADC_CH0, &adcch_conf);

	adc_set_conversion_parameters(&adc_conf, ADC_SIGN_OFF, ADC_RES_12, ADC_REF_AREFA); // use pin PA0 as reference of 2.5v (generated by IC3)
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_FREERUN_SWEEP, 4, 0); // maximal 4 virtual channels
	adc_set_clock_rate(&adc_conf, 5000UL); // 5 kHz should more then enough
	adc_set_callback(&ADCA, &adcHandler);
	adc_write_configuration(&ADCA, &adc_conf);
	adcch_enable_interrupt(&adcch_conf);

	// the Xmega has only 4 virtual channels, because we need 6, we toggle on 2 channels

	// angle and tacho have their own virtual channel because they are in the ball handler pid loop
	// tacho connected to PA7 / J10
	adcch_set_input(&adcch_conf, ADCCH_POS_PIN7, ADCCH_NEG_NONE, 1);
	adcch_write_configuration(&ADCA, ADC_CH0, &adcch_conf);

	// angle connected to PA6 / J2
	// if there is no ball handler an external NTC might be connected to this input to measure the motor temperature
	adcch_set_input(&adcch_conf, ADCCH_NEG_PIN6, ADCCH_NEG_NONE, 1);
	adcch_write_configuration(&ADCA, ADC_CH1, &adcch_conf);

	// use virtual channel 2 to measure current of return path bridge A (PA2) and bridge B (PA3)
	// the current measurement is not accurate, this is caused by the analog signal from the drv8301
	// TODO: investigate if the quality can be improved
	measureCurrentA = true;
	adcch_set_input(&adcch_conf, ADCCH_POS_PIN2, ADCCH_NEG_NONE, 1); // current return bridge A
	// adcch_set_input(&adcch_conf, ADCCH_POS_PIN3, ADCCH_NEG_NONE, 1); // current return bridge B
	adcch_write_configuration(&ADCA, ADC_CH2, &adcch_conf);

	// the last virtual channel is shared between board voltage (PA4) and on board temperature (PA5)
	measureBoardTemperature = true;
	// adcch_set_input(&adcch_conf, ADCCH_POS_PIN4, ADCCH_NEG_NONE, 1); // battery voltage
	adcch_set_input(&adcch_conf, ADCCH_POS_PIN5, ADCCH_NEG_NONE, 1); // board temperature
	adcch_write_configuration(&ADCA, ADC_CH3, &adcch_conf);
 }


void initSafety(){
	error = 0; // clear all safety errors

	safety.tacho = 0;
	safety.angle = 0;
	safety.currentA = 0;
	safety.currentB = 0;
	safety.boardVoltage = 0;
	safety.boardTemp = 0;

	motorTimeoutValue = 0;
	lastValidPacketAge = 65535;

	adcInit(); // setup the adc converter
	adc_enable(&ADCA); // enable the adc converter
}

void taskSafety() {
	// the adc values are captured through in interrupt function

	// safety task runs every 2.5ms
	// far end should set this to 400 for a timeout of 500ms
	// the maximal (65535) configurable timeout can be set to 163.8 seconds
	if( lastValidPacketAge >= motorTimeoutValue ) {
		setMode( MODE_COMMUNICATION_TIMEOUT );
		// TODO error |= SAFETY_COMMUNICATION_TIMEOUT; // investigate how to handle this, shall not be part of the yellow led
	} else {
		lastValidPacketAge++;
	}

	uint8_t mode = getMode();
	if( mode == MODE_COMMUNICATION_TIMEOUT || mode == MODE_DISABLE_MOTOR_POWER || mode == MODE_ZERO_CURRENT_CALIBRATION ) {
		if( adcCalibrationCounter < 255 ) { // 255 is done value
			adcCalibrationCounter++;
		}
		if( adcCalibrationCounter < 32 ) {
			// wait until motor has stopped
			tachoSum = 0;
			angleSum = 0;
		} else if( adcCalibrationCounter < ( 32 + 64 ) ) {
			// use the 64 adc values to reduce the noise
			tachoSum += safety.tacho; // default setPoint for tacho is not 0
			angleSum += safety.angle; // default setPoint for angle is not 0
		} else if( adcCalibrationCounter < ( 32 + 64 + 1 ) ) {
			// calculate average which is the adc value when the ball motor is not spinning
			angleTachoZero.tacho = (32 + tachoSum)>>6; // divide by 64 and round (32 = 0.5 is for the rounding)
			angleTachoZero.angle = (32 + angleSum)>>6;
			angleTachoInitialized = true;
			// keep on calibration, until mode changed, it does not harm if the last calibration cycle was not completed
			adcCalibrationCounter = 0;
		}
	} else {
		adcCalibrationCounter = 0; // restart calibration next time the motor is disabled again
	}

	if( mode == MODE_PID_ANGLE && angleTachoZero.angle != 0 ) {
		// robot 4 ball handler right shows range of 2980 to 4096 (hard bump)
		// only check when angle is used and angleZero has been calibrated
		if( safety.angle == 4095 ) {
			// this error might appear when noise on the hall sensor
			error |= SAFETY_ANGLE_VALUE_TOO_HIGH;
		}
		if( safety.angle < 200 ) {
			error |= SAFETY_ANGLE_VALUE_TOO_LOW;
		}
	}

	if( ( mode == MODE_PID_ANGLE || mode == MODE_PID_TACHO ) && angleTachoZero.angle != 0 ) {
		// only check when tacho is used and angleZero and tachoZero have been calibrated
		// the values are described in pid.c
		if( safety.tacho > 3983 ) {
			error |= SAFETY_TACHO_VALUE_TOO_HIGH;
		}
		if( safety.tacho < 671 ) {
			error |= SAFETY_TACHO_VALUE_TOO_LOW;
		}
	}

	// TODO: add checking if adc values are within ranges
	// TODO: check if pid result matches motor current within certain ranges
	// TODO: check if pid result matches velocity within certain ranges
}

safetyT getSafety() {
	return safety;
}

void validPacketRecieved(){
	lastValidPacketAge = 0;
}

void setMotorTimeout( uint16_t value ){
	motorTimeoutValue = value;
}

uint16_t getMotorTimeout(){
	return motorTimeoutValue;
}

angleTachoT getAngleTachoZero() {
	if( ! angleTachoInitialized ) {
		error |= SAFETY_ANGLE_TACHO_UNINITIALZED;
	}
	return angleTachoZero;
}

uint16_t getSafetyError() {
	return error;
}

void clearSafetyError( uint16_t value ){
	error &= ~value; // clear only the bits set in value
}
