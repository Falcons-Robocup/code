""" 
 2014 - 2020 ASML Holding N.V. All Rights Reserved. 
 
 NOTICE: 
 
 IP OWNERSHIP All information contained herein is, and remains the property of ASML Holding N.V. The intellectual and technical concepts contained herein are proprietary to ASML Holding N.V. and may be covered by patents or patent applications and are protected by trade secret or copyright law. NON-COMMERCIAL USE Except for non-commercial purposes and with inclusion of this Notice, redistribution and use in source or binary forms, with or without modification, is strictly forbidden, unless prior written permission is obtained from ASML Holding N.V. 
 
 NO WARRANTY ASML EXPRESSLY DISCLAIMS ALL WARRANTIES WHETHER WRITTEN OR ORAL, OR WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED, ANY IMPLIED WARRANTIES OR CONDITIONS OF MERCHANTABILITY, NON-INFRINGEMENT, TITLE OR FITNESS FOR A PARTICULAR PURPOSE. 
 
 NO LIABILITY IN NO EVENT SHALL ASML HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION ANY LOST DATA, LOST PROFITS OR COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES), HOWEVER CAUSED AND UNDER ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES 
 """ 
 """ 
 2014 - 2020 ASML Holding N.V. All Rights Reserved. 
 
 NOTICE: 
 
 IP OWNERSHIP All information contained herein is, and remains the property of ASML Holding N.V. The intellectual and technical concepts contained herein are proprietary to ASML Holding N.V. and may be covered by patents or patent applications and are protected by trade secret or copyright law. NON-COMMERCIAL USE Except for non-commercial purposes and with inclusion of this Notice, redistribution and use in source or binary forms, with or without modification, is strictly forbidden, unless prior written permission is obtained from ASML Holding N.V. 
 
 NO WARRANTY ASML EXPRESSLY DISCLAIMS ALL WARRANTIES WHETHER WRITTEN OR ORAL, OR WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED, ANY IMPLIED WARRANTIES OR CONDITIONS OF MERCHANTABILITY, NON-INFRINGEMENT, TITLE OR FITNESS FOR A PARTICULAR PURPOSE. 
 
 NO LIABILITY IN NO EVENT SHALL ASML HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION ANY LOST DATA, LOST PROFITS OR COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES), HOWEVER CAUSED AND UNDER ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES 
 """ 
 #!/usr/bin/env python3
#
# Build hook to generate code derived from enum definitions
# * enum2str conversions
# * python bindings


import sys, os, glob
import datetime
from collections import OrderedDict
import argparse
import clang.cindex
clang.cindex.Config.set_library_file("/usr/lib/x86_64-linux-gnu/libclang-10.so")



# output files
generatedEnumHpp = "generated_enum2str.hpp"
generatedEnumPy = "sharedTypes.py"


# code templates

templateHppFile = """// this file is generated by {THIS_SCRIPT} on {DATE}
// ! do not check it in, or attempt to modify !

#ifndef GENERATED_ENUM2STR_HPP_
#define GENERATED_ENUM2STR_HPP_

{GENERATED_ENUM_ITEMS}

#endif
"""

templateHppEnumItem = """

#include "{INCLUDE_HEADER}"

inline char const *enum2str({ENUM_NAME} const &s)
{
    char const *result = "UNKNOWN";
    switch (s)
    {
{ENUM_VALUE_CASES}
        default:
            result = "UNKNOWN";
    }
    return result;
}
"""

templateHppEnumCase = """        case {ENUM_NAME}::{ENUM_VALUE_STR}:
            result = "{ENUM_VALUE_STR}";
            break;
"""

templatePyFile = """# this file is generated by {THIS_SCRIPT} on {DATE}
# ! do not check it in, or attempt to modify !

from enum import Enum

{GENERATED_ENUM_ITEMS}
"""

templatePyEnum = """
class {ENUM_NAME}(Enum):
{ENUM_VALUE_CASES}
"""


# small helpers

def codeGen(template, items):
    # next would be simpler but is not robust because it cannot handle standalone characters '{'
    # r = template.format(**items)
    r = template
    for k in items.keys():
        r = r.replace('{' + k + '}', str(items[k]))
    return r

    
class enum:
    def __init__(self, name, type, src):
        self.name = name
        self.type = type
        self.source = src
        self.items = OrderedDict() # string -> int value
    def __str__(self):
        return self.type + " " + str(self.items)


# main parser
        
class parseEnumsInHeader:
    def __init__(self, filename):
        self.filename = filename
        self.enums = []
        self.currentEnum = None # used during parsing
        self.parse()
    def getEnums(self):
        return self.enums
    def parse(self):
        index = clang.cindex.Index.create()
        # helper functions
        def finish(node):
            if self.currentEnum != None:
                if str(node.location.file) in ["None", self.filename]:
                    self.enums.append(self.currentEnum)
        def walk(node, depth):
            #print("%sdebug (file=%s kind=%s type=%s loc=%s)" % (" " * depth, self.filename, node.kind, node.type.spelling, node.location.file))
            if node.kind == clang.cindex.CursorKind.ENUM_DECL:
                # finish previous enum
                finish(node)
                # start new enum
                self.currentEnum = enum(node.spelling or node.displayname, node.type.spelling, self.filename)
            if node.kind == clang.cindex.CursorKind.ENUM_CONSTANT_DECL:
                # add value
                self.currentEnum.items[node.spelling] = node.enum_value
            # recurse
            for c in node.get_children():
                # don't go into other files
                if str(c.location.file) == self.filename:
                    walk(c, 1 + depth)
        # start parsing
        node = index.parse(self.filename).cursor
        walk(node, 0)
        # finish last enum
        finish(node)


def generationRequired(args):
    headers = glob.glob(args.inputfolder + '/*.hpp')
    if ((os.path.exists(args.outputhpp)) and (os.path.exists(args.outputpy))):
        hpp_mtime = os.path.getmtime(args.outputhpp)
        py_mtime = os.path.getmtime(args.outputpy)
        for h in headers:
            if (os.path.getmtime(h) > hpp_mtime) or (os.path.getmtime(h) > py_mtime):
                if args.verbose:
                    print("Generation required for (at least) header file: {}".format(h))
                return True
    else:
        if args.verbose:
            print("Output file(s) not existing: generation is required")
        return True
    if args.verbose:
        print("Generation is not required")
    return False


def findEnums(args):
    headers = glob.glob(args.inputfolder + '/*.hpp')
    result = []
    if args.verbose:
        print("scanning for enums in %s/*.hpp" % (args.inputfolder))
    for h in headers:
        if generatedEnumHpp in h:
            continue # ignore output, if written into same folder
        if args.verbose:
            print("  %s" % (h))
        # parse the file
        p = parseEnumsInHeader(h)
        for e in p.getEnums():
            if args.verbose:
                print("     %s" % (e))
            result.append(e)
    return result


def writeGeneratedHppEnum2str(args, enums):
    filename = args.outputhpp
    # generate code
    try:
        generatedCode = ""
        # generate code per enum
        for e in enums:
            s = ""
            m = {}
            m["INCLUDE_HEADER"] = os.path.basename(e.source)
            m["ENUM_NAME"] = e.name
            m["ENUM_ITEMS"] = e.items
            for k in m["ENUM_ITEMS"].keys():
                m["ENUM_VALUE_STR"] = k
                s += templateHppEnumCase.format(**m)
            m["ENUM_VALUE_CASES"] = s
            generatedCode += codeGen(templateHppEnumItem, m)
        # wrap and finalize the header
        m = {}
        m["GENERATED_ENUM_ITEMS"] = generatedCode
        m["THIS_SCRIPT"] = sys.argv[0]
        m["DATE"] = str(datetime.datetime.now())
        generatedCode = codeGen(templateHppFile, m)
    except Exception as e:
        raise RuntimeError('Unexpected error while generating code: {}'.format(str(e)))
    # write to file
    if args.verbose:
        print("writing file %s" % (filename))
    writeToFile(filename, generatedCode)

    
def writeGeneratedPyEnum2str(args, enums):
    filename = args.outputpy
    # generate code
    try:
        generatedCode = ""
        # generate code per enum
        for e in enums:
            s = ""
            for k in e.items.keys():
                s += "    {} = {}\n".format(k, e.items[k])
            m = {}
            m["ENUM_NAME"] = e.name
            m["ENUM_VALUE_CASES"] = s
            generatedCode += codeGen(templatePyEnum, m)
        # wrap and finalize the header
        m = {}
        m["GENERATED_ENUM_ITEMS"] = generatedCode
        m["THIS_SCRIPT"] = sys.argv[0]
        m["DATE"] = str(datetime.datetime.now())
        generatedCode = codeGen(templatePyFile, m)
    except Exception as e:
        raise RuntimeError('Unexpected error while generating code: {}'.format(str(e)))
    # write to file
    if args.verbose:
        print("writing file %s" % (filename))
    writeToFile(filename, generatedCode)


def writeToFile(filename, generatedCode):
    try:
        f = open(filename, 'w')
    except IOError as e:
        raise RuntimeError('Unable to open file {}: {}'.format(filename, e.strerror))
    except Exception as e:
        raise RuntimeError('Unexpected error while trying to open file {}: {}'.format(filename, str(e)))
    try:
        print(generatedCode, file=f)
        f.close()
    except IOError as e:
        raise RuntimeError('Error while writing file {}: {}'.format(filename, e.strerror))
    except Exception as e:
        raise RuntimeError('Unexpected error while writing file {}: {}'.format(filename, str(e)))


if __name__ == '__main__':
    # Argument parsing.
    descriptionTxt = 'Generate code derived from enums.\nExample usage: python ./src/generateEnums.py -v -i ./include -o ./include/generated_enum2str.hpp -p ./src/sharedTypes.py'
    parser     = argparse.ArgumentParser(description=descriptionTxt)
    parser.add_argument('-i', '--inputfolder', help='folder containing files to scan')
    parser.add_argument('-o', '--outputhpp', help='output C++ header file')
    parser.add_argument('-p', '--outputpy', help='output python file')
    parser.add_argument('-v', '--verbose', help='print details on what is happening', action='store_true')
    args       = parser.parse_args()

    if generationRequired(args):
        # gather enums
        enums = findEnums(args)

        # generate
        writeGeneratedHppEnum2str(args, enums) # outputhpp
        writeGeneratedPyEnum2str(args, enums) # outputpy
