# Copyright 2019-2021 Jan Feitsma (Falcons)
# SPDX-License-Identifier: Apache-2.0
#!/usr/bin/env python3
#
# Build hook to generate code derived from enum definitions
# * enum2str conversions
# * python bindings


import sys, os, glob
import datetime
from collections import OrderedDict
import argparse
import clang.cindex
clang.cindex.Config.set_library_file("/usr/lib/x86_64-linux-gnu/libclang-10.so")



# output files
generatedEnumHpp = "generated_enum2str.hpp"
generatedEnumPy = "sharedTypes.py"


# code templates

templateHppFile = """// this file is generated by {THIS_SCRIPT} on {DATE}
// ! do not check it in, or attempt to modify !

#ifndef {DEF_PREFIX}_GENERATED_ENUM2STR_HPP_
#define {DEF_PREFIX}_GENERATED_ENUM2STR_HPP_

#include <ostream>
#include <unordered_map>

{GENERATED_ENUM_ITEMS}

#endif
"""

templateHppEnumItem = """

#include "{INCLUDE_HEADER}"

constexpr char const *enum2str(const {ENUM_NAME} s)
{
    return
{ENUM_VALUE_CASES}
        "UNKNOWN"
        ;
}

inline std::ostream& operator<<(std::ostream & os, const {ENUM_NAME} s)
{
    return os << enum2str(s);
}

inline {ENUM_NAME} str2enum(const std::string& s, {ENUM_NAME}& out)
{
    std::unordered_map<std::string,{ENUM_NAME}> lut;

{STR_TO_ENUM_VALUES}
    auto it = lut.find(s);
    if (it != lut.end())
    {
        out = it->second;
        return it->second;
    }
    else
    {
        out = ({ENUM_NAME})0;
        return ({ENUM_NAME})0;
    }
}
"""

templateEnum2StrHppEnumCase = """        s == {ENUM_NAME}::{ENUM_VALUE_STR} ? "{ENUM_VALUE_STR}" :
"""

templateStr2EnumHppEnumCase = """    lut.insert( std::make_pair( "{ENUM_VALUE_STR}", {ENUM_NAME}::{ENUM_VALUE_STR} ) );
"""

templatePyFile = """# this file is generated by {THIS_SCRIPT} on {DATE}
# ! do not check it in, or attempt to modify !

from enum import Enum

{GENERATED_ENUM_ITEMS}
"""

templatePyEnum = """
class {ENUM_NAME}(Enum):
{ENUM_VALUE_CASES}
"""


# small helpers

def codeGen(template, items):
    # next would be simpler but is not robust because it cannot handle standalone characters '{'
    # r = template.format(**items)
    r = template
    for k in items.keys():
        r = r.replace('{' + k + '}', str(items[k]))
    return r

    
class enum:
    def __init__(self, name, type, src):
        self.name = name
        self.type = type
        self.source = src
        self.items = OrderedDict() # string -> int value
    def __str__(self):
        return self.type + " " + str(self.items)


# main parser
        
class parseEnumsInHeader:
    def __init__(self, filename):
        self.filename = filename
        self.enums = []
        self.currentEnum = None # used during parsing
        self.parse()
    def getEnums(self):
        return self.enums
    def parse(self):
        index = clang.cindex.Index.create()
        # helper functions
        def finish(node):
            if self.currentEnum != None:
                if str(node.location.file) in ["None", self.filename]:
                    self.enums.append(self.currentEnum)
        def walk(node, depth):
            #print("%sdebug (file=%s kind=%s type=%s loc=%s)" % (" " * depth, self.filename, node.kind, node.type.spelling, node.location.file))
            if node.kind == clang.cindex.CursorKind.ENUM_DECL:
                # finish previous enum
                finish(node)
                # start new enum
                self.currentEnum = enum(node.spelling or node.displayname, node.type.spelling, self.filename)
            if node.kind == clang.cindex.CursorKind.ENUM_CONSTANT_DECL:
                # add value
                self.currentEnum.items[node.spelling] = node.enum_value
            # recurse
            for c in node.get_children():
                # don't go into other files
                if str(c.location.file) == self.filename:
                    walk(c, 1 + depth)
        # start parsing
        node = index.parse(self.filename).cursor
        walk(node, 0)
        # finish last enum
        finish(node)


def generationRequired(args):
    headers = glob.glob(args.inputfolder + '/*.hpp')
    if ((os.path.exists(args.outputhpp)) and (os.path.exists(args.outputpy))):
        hpp_mtime = os.path.getmtime(args.outputhpp)
        py_mtime = os.path.getmtime(args.outputpy)
        for h in headers:
            if (os.path.getmtime(h) > hpp_mtime) or (os.path.getmtime(h) > py_mtime):
                if args.verbose:
                    print("generateEnums.py: generation might be required for (at least) header file: {}".format(h))
                return True
    else:
        if args.verbose:
            print("generateEnums.py: output file(s) not existing: generation is required")
        return True
    if args.verbose:
        print("generateEnums.py: generation is not required")
    return False


def findEnums(args):
    headers = glob.glob(args.inputfolder + '/*.hpp')
    result = []
    if args.verbose:
        print("generateEnums.py: scanning for enums in %s/*.hpp" % (args.inputfolder))
    for h in headers:
        if generatedEnumHpp in h:
            continue # ignore output, if written into same folder
        if args.extraverbose:
            print("  %s" % (h))
        # parse the file
        p = parseEnumsInHeader(h)
        for e in p.getEnums():
            if args.extraverbose:
                print("     %s" % (e))
            result.append(e)
    return result


def writeGeneratedHppEnum2str(args, enums):
    filename = args.outputhpp
    # generate code
    try:
        generatedCode = ""
        # generate code per enum
        for e in enums:
            s = ""
            s2 = ""
            m = {}
            m["INCLUDE_HEADER"] = os.path.basename(e.source)
            m["ENUM_NAME"] = e.name
            m["ENUM_ITEMS"] = e.items
            for k in m["ENUM_ITEMS"].keys():
                m["ENUM_VALUE_STR"] = k
                s += templateEnum2StrHppEnumCase.format(**m)
                s2 += templateStr2EnumHppEnumCase.format(**m)
            m["ENUM_VALUE_CASES"] = s
            m["STR_TO_ENUM_VALUES"] = s2
            generatedCode += codeGen(templateHppEnumItem, m)
        # wrap and finalize the header
        m = {}
        m["DEF_PREFIX"] = args.define_prefix
        m["GENERATED_ENUM_ITEMS"] = generatedCode
        m["THIS_SCRIPT"] = sys.argv[0]
        m["DATE"] = str(datetime.datetime.now())
        generatedCode = codeGen(templateHppFile, m)
    except Exception as e:
        raise RuntimeError('Unexpected error while generating code: {}'.format(str(e)))
    # write to file
    written = writeToFile(filename, generatedCode)
    if args.verbose:
        if written:
            print("generateEnums.py: written file %s" % (filename))
        else:
            print("generateEnums.py: generated content for %s is exactly the same --> not overwriting the previous file" % (filename))

    
def writeGeneratedPyEnum2str(args, enums):
    filename = args.outputpy
    # generate code
    try:
        generatedCode = ""
        # generate code per enum
        for e in enums:
            s = ""
            for k in e.items.keys():
                s += "    {} = {}\n".format(k, e.items[k])
            m = {}
            m["ENUM_NAME"] = e.name
            m["ENUM_VALUE_CASES"] = s
            generatedCode += codeGen(templatePyEnum, m)
        # wrap and finalize the header
        m = {}
        m["GENERATED_ENUM_ITEMS"] = generatedCode
        m["THIS_SCRIPT"] = sys.argv[0]
        m["DATE"] = str(datetime.datetime.now())
        generatedCode = codeGen(templatePyFile, m)
    except Exception as e:
        raise RuntimeError('Unexpected error while generating code: {}'.format(str(e)))
    # write to file
    written = writeToFile(filename, generatedCode)
    if args.verbose:
        if written:
            print("generateEnums.py: written file %s" % (filename))
        else:
            print("generateEnums.py: generated content for %s is exactly the same --> not overwriting the previous file" % (filename))


def writeToFile(filename, generatedCode):
    # first check if we really should be writing to the file -- 
    # in case of switching branches, the change of some file timestamps might bring us here
    # but content wise there is no change, and the build time would be quite long for no good reason
    # so let's compare content
    generatedLines = generatedCode.split("\n")
    currentLines = [""] * 3
    try:
        with open(filename) as f:
            currentLines = f.read().splitlines()
        if "\n".join(generatedLines[2:]) == "\n".join(currentLines[2:]): # first two lines contain a timestamp
            return False
    except IOError as e:
        pass
        # typically the file doesn't exist in a clean environment, no need to warn about it
        #print("WARNING: Unable to open file {}: {}".format(filename, e.strerror))

    # now write to file
    try:
        f = open(filename, 'w')
    except IOError as e:
        raise RuntimeError('Unable to open file {}: {}'.format(filename, e.strerror))
    except Exception as e:
        raise RuntimeError('Unexpected error while trying to open file {}: {}'.format(filename, str(e)))
    try:
        print(generatedCode, file=f)
        f.close()
    except IOError as e:
        raise RuntimeError('Error while writing file {}: {}'.format(filename, e.strerror))
    except Exception as e:
        raise RuntimeError('Unexpected error while writing file {}: {}'.format(filename, str(e)))
    return True


if __name__ == '__main__':
    # Argument parsing.
    descriptionTxt = 'Generate code derived from enums.\nExample usage: python ./src/generateEnums.py -v -i ./include -o ./include/generated_enum2str.hpp -p ./src/generated_enum2str.py MYPACKAGE'
    parser     = argparse.ArgumentParser(description=descriptionTxt)
    parser.add_argument('-i', '--inputfolder', help='folder containing files to scan')
    parser.add_argument('-o', '--outputhpp', help='output C++ header file')
    parser.add_argument('-p', '--outputpy', help='output python file')
    parser.add_argument('-v', '--extraverbose', help='print more details on what is happening', action='store_true')
    parser.add_argument('define_prefix', help='header define prefix', default='')
    args       = parser.parse_args()
    args.verbose = True # default: few lines of useful output on what's happening high-level

    if generationRequired(args):
        # gather enums
        enums = findEnums(args)

        # generate
        writeGeneratedHppEnum2str(args, enums) # outputhpp
        writeGeneratedPyEnum2str(args, enums) # outputpy
