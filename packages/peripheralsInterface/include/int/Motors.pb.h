// Copyright 2019 Erik Kouters (Falcons)
// SPDX-License-Identifier: Apache-2.0
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Motors.proto

#ifndef PROTOBUF_INCLUDED_Motors_2eproto
#define PROTOBUF_INCLUDED_Motors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Motors_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_Motors_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_Motors_2eproto();
namespace motors {
class BallhandlerAngles;
class BallhandlerAnglesDefaultTypeInternal;
extern BallhandlerAnglesDefaultTypeInternal _BallhandlerAngles_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class MotorPID;
class MotorPIDDefaultTypeInternal;
extern MotorPIDDefaultTypeInternal _MotorPID_default_instance_;
class MotorVector;
class MotorVectorDefaultTypeInternal;
extern MotorVectorDefaultTypeInternal _MotorVector_default_instance_;
class Publish;
class PublishDefaultTypeInternal;
extern PublishDefaultTypeInternal _Publish_default_instance_;
class RobotVector;
class RobotVectorDefaultTypeInternal;
extern RobotVectorDefaultTypeInternal _RobotVector_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace motors
namespace google {
namespace protobuf {
template<> ::motors::BallhandlerAngles* Arena::CreateMaybeMessage<::motors::BallhandlerAngles>(Arena*);
template<> ::motors::Empty* Arena::CreateMaybeMessage<::motors::Empty>(Arena*);
template<> ::motors::MotorPID* Arena::CreateMaybeMessage<::motors::MotorPID>(Arena*);
template<> ::motors::MotorVector* Arena::CreateMaybeMessage<::motors::MotorVector>(Arena*);
template<> ::motors::Publish* Arena::CreateMaybeMessage<::motors::Publish>(Arena*);
template<> ::motors::RobotVector* Arena::CreateMaybeMessage<::motors::RobotVector>(Arena*);
template<> ::motors::Status* Arena::CreateMaybeMessage<::motors::Status>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace motors {

// ===================================================================

class Empty :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(nullptr);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:motors.Empty)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// -------------------------------------------------------------------

class Status :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool enabled = 1;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:motors.Status)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool enabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// -------------------------------------------------------------------

class BallhandlerAngles :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.BallhandlerAngles) */ {
 public:
  BallhandlerAngles();
  virtual ~BallhandlerAngles();

  BallhandlerAngles(const BallhandlerAngles& from);

  inline BallhandlerAngles& operator=(const BallhandlerAngles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallhandlerAngles(BallhandlerAngles&& from) noexcept
    : BallhandlerAngles() {
    *this = ::std::move(from);
  }

  inline BallhandlerAngles& operator=(BallhandlerAngles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BallhandlerAngles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BallhandlerAngles* internal_default_instance() {
    return reinterpret_cast<const BallhandlerAngles*>(
               &_BallhandlerAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BallhandlerAngles* other);
  friend void swap(BallhandlerAngles& a, BallhandlerAngles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallhandlerAngles* New() const final {
    return CreateMaybeMessage<BallhandlerAngles>(nullptr);
  }

  BallhandlerAngles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BallhandlerAngles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BallhandlerAngles& from);
  void MergeFrom(const BallhandlerAngles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BallhandlerAngles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float right = 1;
  void clear_right();
  static const int kRightFieldNumber = 1;
  float right() const;
  void set_right(float value);

  // float left = 2;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  float left() const;
  void set_left(float value);

  // @@protoc_insertion_point(class_scope:motors.BallhandlerAngles)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float right_;
  float left_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// -------------------------------------------------------------------

class RobotVector :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.RobotVector) */ {
 public:
  RobotVector();
  virtual ~RobotVector();

  RobotVector(const RobotVector& from);

  inline RobotVector& operator=(const RobotVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotVector(RobotVector&& from) noexcept
    : RobotVector() {
    *this = ::std::move(from);
  }

  inline RobotVector& operator=(RobotVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RobotVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotVector* internal_default_instance() {
    return reinterpret_cast<const RobotVector*>(
               &_RobotVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RobotVector* other);
  friend void swap(RobotVector& a, RobotVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotVector* New() const final {
    return CreateMaybeMessage<RobotVector>(nullptr);
  }

  RobotVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotVector& from);
  void MergeFrom(const RobotVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float phi = 3;
  void clear_phi();
  static const int kPhiFieldNumber = 3;
  float phi() const;
  void set_phi(float value);

  // @@protoc_insertion_point(class_scope:motors.RobotVector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float phi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// -------------------------------------------------------------------

class MotorVector :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.MotorVector) */ {
 public:
  MotorVector();
  virtual ~MotorVector();

  MotorVector(const MotorVector& from);

  inline MotorVector& operator=(const MotorVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorVector(MotorVector&& from) noexcept
    : MotorVector() {
    *this = ::std::move(from);
  }

  inline MotorVector& operator=(MotorVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MotorVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorVector* internal_default_instance() {
    return reinterpret_cast<const MotorVector*>(
               &_MotorVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MotorVector* other);
  friend void swap(MotorVector& a, MotorVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorVector* New() const final {
    return CreateMaybeMessage<MotorVector>(nullptr);
  }

  MotorVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorVector& from);
  void MergeFrom(const MotorVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float ballhandler_motor_right = 1;
  void clear_ballhandler_motor_right();
  static const int kBallhandlerMotorRightFieldNumber = 1;
  float ballhandler_motor_right() const;
  void set_ballhandler_motor_right(float value);

  // float ballhandler_motor_left = 2;
  void clear_ballhandler_motor_left();
  static const int kBallhandlerMotorLeftFieldNumber = 2;
  float ballhandler_motor_left() const;
  void set_ballhandler_motor_left(float value);

  // float drive_motor_right = 3;
  void clear_drive_motor_right();
  static const int kDriveMotorRightFieldNumber = 3;
  float drive_motor_right() const;
  void set_drive_motor_right(float value);

  // float drive_motor_left = 4;
  void clear_drive_motor_left();
  static const int kDriveMotorLeftFieldNumber = 4;
  float drive_motor_left() const;
  void set_drive_motor_left(float value);

  // float drive_motor_rear = 5;
  void clear_drive_motor_rear();
  static const int kDriveMotorRearFieldNumber = 5;
  float drive_motor_rear() const;
  void set_drive_motor_rear(float value);

  // @@protoc_insertion_point(class_scope:motors.MotorVector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float ballhandler_motor_right_;
  float ballhandler_motor_left_;
  float drive_motor_right_;
  float drive_motor_left_;
  float drive_motor_rear_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// -------------------------------------------------------------------

class MotorPID :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.MotorPID) */ {
 public:
  MotorPID();
  virtual ~MotorPID();

  MotorPID(const MotorPID& from);

  inline MotorPID& operator=(const MotorPID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorPID(MotorPID&& from) noexcept
    : MotorPID() {
    *this = ::std::move(from);
  }

  inline MotorPID& operator=(MotorPID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MotorPID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorPID* internal_default_instance() {
    return reinterpret_cast<const MotorPID*>(
               &_MotorPID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MotorPID* other);
  friend void swap(MotorPID& a, MotorPID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorPID* New() const final {
    return CreateMaybeMessage<MotorPID>(nullptr);
  }

  MotorPID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorPID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorPID& from);
  void MergeFrom(const MotorPID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorPID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 p_gain = 1;
  void clear_p_gain();
  static const int kPGainFieldNumber = 1;
  ::google::protobuf::uint32 p_gain() const;
  void set_p_gain(::google::protobuf::uint32 value);

  // uint32 i_gain = 2;
  void clear_i_gain();
  static const int kIGainFieldNumber = 2;
  ::google::protobuf::uint32 i_gain() const;
  void set_i_gain(::google::protobuf::uint32 value);

  // uint32 ff_velocity_gain = 3;
  void clear_ff_velocity_gain();
  static const int kFfVelocityGainFieldNumber = 3;
  ::google::protobuf::uint32 ff_velocity_gain() const;
  void set_ff_velocity_gain(::google::protobuf::uint32 value);

  // uint32 ff_acceleration_gain = 4;
  void clear_ff_acceleration_gain();
  static const int kFfAccelerationGainFieldNumber = 4;
  ::google::protobuf::uint32 ff_acceleration_gain() const;
  void set_ff_acceleration_gain(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:motors.MotorPID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 p_gain_;
  ::google::protobuf::uint32 i_gain_;
  ::google::protobuf::uint32 ff_velocity_gain_;
  ::google::protobuf::uint32 ff_acceleration_gain_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// -------------------------------------------------------------------

class Publish :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:motors.Publish) */ {
 public:
  Publish();
  virtual ~Publish();

  Publish(const Publish& from);

  inline Publish& operator=(const Publish& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Publish(Publish&& from) noexcept
    : Publish() {
    *this = ::std::move(from);
  }

  inline Publish& operator=(Publish&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Publish& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Publish* internal_default_instance() {
    return reinterpret_cast<const Publish*>(
               &_Publish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Publish* other);
  friend void swap(Publish& a, Publish& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Publish* New() const final {
    return CreateMaybeMessage<Publish>(nullptr);
  }

  Publish* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Publish>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Publish& from);
  void MergeFrom(const Publish& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Publish* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .motors.Status ballhandlers_enabled = 1;
  bool has_ballhandlers_enabled() const;
  void clear_ballhandlers_enabled();
  static const int kBallhandlersEnabledFieldNumber = 1;
  const ::motors::Status& ballhandlers_enabled() const;
  ::motors::Status* release_ballhandlers_enabled();
  ::motors::Status* mutable_ballhandlers_enabled();
  void set_allocated_ballhandlers_enabled(::motors::Status* ballhandlers_enabled);

  // .motors.BallhandlerAngles ballhandler_angles = 2;
  bool has_ballhandler_angles() const;
  void clear_ballhandler_angles();
  static const int kBallhandlerAnglesFieldNumber = 2;
  const ::motors::BallhandlerAngles& ballhandler_angles() const;
  ::motors::BallhandlerAngles* release_ballhandler_angles();
  ::motors::BallhandlerAngles* mutable_ballhandler_angles();
  void set_allocated_ballhandler_angles(::motors::BallhandlerAngles* ballhandler_angles);

  // .motors.BallhandlerAngles ballhandler_angle_setpoints = 3;
  bool has_ballhandler_angle_setpoints() const;
  void clear_ballhandler_angle_setpoints();
  static const int kBallhandlerAngleSetpointsFieldNumber = 3;
  const ::motors::BallhandlerAngles& ballhandler_angle_setpoints() const;
  ::motors::BallhandlerAngles* release_ballhandler_angle_setpoints();
  ::motors::BallhandlerAngles* mutable_ballhandler_angle_setpoints();
  void set_allocated_ballhandler_angle_setpoints(::motors::BallhandlerAngles* ballhandler_angle_setpoints);

  // .motors.Status drive_motors_enabled = 4;
  bool has_drive_motors_enabled() const;
  void clear_drive_motors_enabled();
  static const int kDriveMotorsEnabledFieldNumber = 4;
  const ::motors::Status& drive_motors_enabled() const;
  ::motors::Status* release_drive_motors_enabled();
  ::motors::Status* mutable_drive_motors_enabled();
  void set_allocated_drive_motors_enabled(::motors::Status* drive_motors_enabled);

  // .motors.RobotVector robot_velocity = 5;
  bool has_robot_velocity() const;
  void clear_robot_velocity();
  static const int kRobotVelocityFieldNumber = 5;
  const ::motors::RobotVector& robot_velocity() const;
  ::motors::RobotVector* release_robot_velocity();
  ::motors::RobotVector* mutable_robot_velocity();
  void set_allocated_robot_velocity(::motors::RobotVector* robot_velocity);

  // .motors.RobotVector robot_position = 6;
  bool has_robot_position() const;
  void clear_robot_position();
  static const int kRobotPositionFieldNumber = 6;
  const ::motors::RobotVector& robot_position() const;
  ::motors::RobotVector* release_robot_position();
  ::motors::RobotVector* mutable_robot_position();
  void set_allocated_robot_position(::motors::RobotVector* robot_position);

  // .motors.RobotVector robot_velocity_setpoint = 7;
  bool has_robot_velocity_setpoint() const;
  void clear_robot_velocity_setpoint();
  static const int kRobotVelocitySetpointFieldNumber = 7;
  const ::motors::RobotVector& robot_velocity_setpoint() const;
  ::motors::RobotVector* release_robot_velocity_setpoint();
  ::motors::RobotVector* mutable_robot_velocity_setpoint();
  void set_allocated_robot_velocity_setpoint(::motors::RobotVector* robot_velocity_setpoint);

  // .motors.Status software_on = 8;
  bool has_software_on() const;
  void clear_software_on();
  static const int kSoftwareOnFieldNumber = 8;
  const ::motors::Status& software_on() const;
  ::motors::Status* release_software_on();
  ::motors::Status* mutable_software_on();
  void set_allocated_software_on(::motors::Status* software_on);

  // .motors.Status inplay = 9;
  bool has_inplay() const;
  void clear_inplay();
  static const int kInplayFieldNumber = 9;
  const ::motors::Status& inplay() const;
  ::motors::Status* release_inplay();
  ::motors::Status* mutable_inplay();
  void set_allocated_inplay(::motors::Status* inplay);

  // @@protoc_insertion_point(class_scope:motors.Publish)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::motors::Status* ballhandlers_enabled_;
  ::motors::BallhandlerAngles* ballhandler_angles_;
  ::motors::BallhandlerAngles* ballhandler_angle_setpoints_;
  ::motors::Status* drive_motors_enabled_;
  ::motors::RobotVector* robot_velocity_;
  ::motors::RobotVector* robot_position_;
  ::motors::RobotVector* robot_velocity_setpoint_;
  ::motors::Status* software_on_;
  ::motors::Status* inplay_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Motors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Status

// bool enabled = 1;
inline void Status::clear_enabled() {
  enabled_ = false;
}
inline bool Status::enabled() const {
  // @@protoc_insertion_point(field_get:motors.Status.enabled)
  return enabled_;
}
inline void Status::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:motors.Status.enabled)
}

// -------------------------------------------------------------------

// BallhandlerAngles

// float right = 1;
inline void BallhandlerAngles::clear_right() {
  right_ = 0;
}
inline float BallhandlerAngles::right() const {
  // @@protoc_insertion_point(field_get:motors.BallhandlerAngles.right)
  return right_;
}
inline void BallhandlerAngles::set_right(float value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:motors.BallhandlerAngles.right)
}

// float left = 2;
inline void BallhandlerAngles::clear_left() {
  left_ = 0;
}
inline float BallhandlerAngles::left() const {
  // @@protoc_insertion_point(field_get:motors.BallhandlerAngles.left)
  return left_;
}
inline void BallhandlerAngles::set_left(float value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:motors.BallhandlerAngles.left)
}

// -------------------------------------------------------------------

// RobotVector

// float x = 1;
inline void RobotVector::clear_x() {
  x_ = 0;
}
inline float RobotVector::x() const {
  // @@protoc_insertion_point(field_get:motors.RobotVector.x)
  return x_;
}
inline void RobotVector::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:motors.RobotVector.x)
}

// float y = 2;
inline void RobotVector::clear_y() {
  y_ = 0;
}
inline float RobotVector::y() const {
  // @@protoc_insertion_point(field_get:motors.RobotVector.y)
  return y_;
}
inline void RobotVector::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:motors.RobotVector.y)
}

// float phi = 3;
inline void RobotVector::clear_phi() {
  phi_ = 0;
}
inline float RobotVector::phi() const {
  // @@protoc_insertion_point(field_get:motors.RobotVector.phi)
  return phi_;
}
inline void RobotVector::set_phi(float value) {
  
  phi_ = value;
  // @@protoc_insertion_point(field_set:motors.RobotVector.phi)
}

// -------------------------------------------------------------------

// MotorVector

// float ballhandler_motor_right = 1;
inline void MotorVector::clear_ballhandler_motor_right() {
  ballhandler_motor_right_ = 0;
}
inline float MotorVector::ballhandler_motor_right() const {
  // @@protoc_insertion_point(field_get:motors.MotorVector.ballhandler_motor_right)
  return ballhandler_motor_right_;
}
inline void MotorVector::set_ballhandler_motor_right(float value) {
  
  ballhandler_motor_right_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorVector.ballhandler_motor_right)
}

// float ballhandler_motor_left = 2;
inline void MotorVector::clear_ballhandler_motor_left() {
  ballhandler_motor_left_ = 0;
}
inline float MotorVector::ballhandler_motor_left() const {
  // @@protoc_insertion_point(field_get:motors.MotorVector.ballhandler_motor_left)
  return ballhandler_motor_left_;
}
inline void MotorVector::set_ballhandler_motor_left(float value) {
  
  ballhandler_motor_left_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorVector.ballhandler_motor_left)
}

// float drive_motor_right = 3;
inline void MotorVector::clear_drive_motor_right() {
  drive_motor_right_ = 0;
}
inline float MotorVector::drive_motor_right() const {
  // @@protoc_insertion_point(field_get:motors.MotorVector.drive_motor_right)
  return drive_motor_right_;
}
inline void MotorVector::set_drive_motor_right(float value) {
  
  drive_motor_right_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorVector.drive_motor_right)
}

// float drive_motor_left = 4;
inline void MotorVector::clear_drive_motor_left() {
  drive_motor_left_ = 0;
}
inline float MotorVector::drive_motor_left() const {
  // @@protoc_insertion_point(field_get:motors.MotorVector.drive_motor_left)
  return drive_motor_left_;
}
inline void MotorVector::set_drive_motor_left(float value) {
  
  drive_motor_left_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorVector.drive_motor_left)
}

// float drive_motor_rear = 5;
inline void MotorVector::clear_drive_motor_rear() {
  drive_motor_rear_ = 0;
}
inline float MotorVector::drive_motor_rear() const {
  // @@protoc_insertion_point(field_get:motors.MotorVector.drive_motor_rear)
  return drive_motor_rear_;
}
inline void MotorVector::set_drive_motor_rear(float value) {
  
  drive_motor_rear_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorVector.drive_motor_rear)
}

// -------------------------------------------------------------------

// MotorPID

// uint32 p_gain = 1;
inline void MotorPID::clear_p_gain() {
  p_gain_ = 0u;
}
inline ::google::protobuf::uint32 MotorPID::p_gain() const {
  // @@protoc_insertion_point(field_get:motors.MotorPID.p_gain)
  return p_gain_;
}
inline void MotorPID::set_p_gain(::google::protobuf::uint32 value) {
  
  p_gain_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorPID.p_gain)
}

// uint32 i_gain = 2;
inline void MotorPID::clear_i_gain() {
  i_gain_ = 0u;
}
inline ::google::protobuf::uint32 MotorPID::i_gain() const {
  // @@protoc_insertion_point(field_get:motors.MotorPID.i_gain)
  return i_gain_;
}
inline void MotorPID::set_i_gain(::google::protobuf::uint32 value) {
  
  i_gain_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorPID.i_gain)
}

// uint32 ff_velocity_gain = 3;
inline void MotorPID::clear_ff_velocity_gain() {
  ff_velocity_gain_ = 0u;
}
inline ::google::protobuf::uint32 MotorPID::ff_velocity_gain() const {
  // @@protoc_insertion_point(field_get:motors.MotorPID.ff_velocity_gain)
  return ff_velocity_gain_;
}
inline void MotorPID::set_ff_velocity_gain(::google::protobuf::uint32 value) {
  
  ff_velocity_gain_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorPID.ff_velocity_gain)
}

// uint32 ff_acceleration_gain = 4;
inline void MotorPID::clear_ff_acceleration_gain() {
  ff_acceleration_gain_ = 0u;
}
inline ::google::protobuf::uint32 MotorPID::ff_acceleration_gain() const {
  // @@protoc_insertion_point(field_get:motors.MotorPID.ff_acceleration_gain)
  return ff_acceleration_gain_;
}
inline void MotorPID::set_ff_acceleration_gain(::google::protobuf::uint32 value) {
  
  ff_acceleration_gain_ = value;
  // @@protoc_insertion_point(field_set:motors.MotorPID.ff_acceleration_gain)
}

// -------------------------------------------------------------------

// Publish

// .motors.Status ballhandlers_enabled = 1;
inline bool Publish::has_ballhandlers_enabled() const {
  return this != internal_default_instance() && ballhandlers_enabled_ != nullptr;
}
inline void Publish::clear_ballhandlers_enabled() {
  if (GetArenaNoVirtual() == nullptr && ballhandlers_enabled_ != nullptr) {
    delete ballhandlers_enabled_;
  }
  ballhandlers_enabled_ = nullptr;
}
inline const ::motors::Status& Publish::ballhandlers_enabled() const {
  const ::motors::Status* p = ballhandlers_enabled_;
  // @@protoc_insertion_point(field_get:motors.Publish.ballhandlers_enabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::Status*>(
      &::motors::_Status_default_instance_);
}
inline ::motors::Status* Publish::release_ballhandlers_enabled() {
  // @@protoc_insertion_point(field_release:motors.Publish.ballhandlers_enabled)
  
  ::motors::Status* temp = ballhandlers_enabled_;
  ballhandlers_enabled_ = nullptr;
  return temp;
}
inline ::motors::Status* Publish::mutable_ballhandlers_enabled() {
  
  if (ballhandlers_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::Status>(GetArenaNoVirtual());
    ballhandlers_enabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.ballhandlers_enabled)
  return ballhandlers_enabled_;
}
inline void Publish::set_allocated_ballhandlers_enabled(::motors::Status* ballhandlers_enabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ballhandlers_enabled_;
  }
  if (ballhandlers_enabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ballhandlers_enabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ballhandlers_enabled, submessage_arena);
    }
    
  } else {
    
  }
  ballhandlers_enabled_ = ballhandlers_enabled;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.ballhandlers_enabled)
}

// .motors.BallhandlerAngles ballhandler_angles = 2;
inline bool Publish::has_ballhandler_angles() const {
  return this != internal_default_instance() && ballhandler_angles_ != nullptr;
}
inline void Publish::clear_ballhandler_angles() {
  if (GetArenaNoVirtual() == nullptr && ballhandler_angles_ != nullptr) {
    delete ballhandler_angles_;
  }
  ballhandler_angles_ = nullptr;
}
inline const ::motors::BallhandlerAngles& Publish::ballhandler_angles() const {
  const ::motors::BallhandlerAngles* p = ballhandler_angles_;
  // @@protoc_insertion_point(field_get:motors.Publish.ballhandler_angles)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::BallhandlerAngles*>(
      &::motors::_BallhandlerAngles_default_instance_);
}
inline ::motors::BallhandlerAngles* Publish::release_ballhandler_angles() {
  // @@protoc_insertion_point(field_release:motors.Publish.ballhandler_angles)
  
  ::motors::BallhandlerAngles* temp = ballhandler_angles_;
  ballhandler_angles_ = nullptr;
  return temp;
}
inline ::motors::BallhandlerAngles* Publish::mutable_ballhandler_angles() {
  
  if (ballhandler_angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::BallhandlerAngles>(GetArenaNoVirtual());
    ballhandler_angles_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.ballhandler_angles)
  return ballhandler_angles_;
}
inline void Publish::set_allocated_ballhandler_angles(::motors::BallhandlerAngles* ballhandler_angles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ballhandler_angles_;
  }
  if (ballhandler_angles) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ballhandler_angles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ballhandler_angles, submessage_arena);
    }
    
  } else {
    
  }
  ballhandler_angles_ = ballhandler_angles;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.ballhandler_angles)
}

// .motors.BallhandlerAngles ballhandler_angle_setpoints = 3;
inline bool Publish::has_ballhandler_angle_setpoints() const {
  return this != internal_default_instance() && ballhandler_angle_setpoints_ != nullptr;
}
inline void Publish::clear_ballhandler_angle_setpoints() {
  if (GetArenaNoVirtual() == nullptr && ballhandler_angle_setpoints_ != nullptr) {
    delete ballhandler_angle_setpoints_;
  }
  ballhandler_angle_setpoints_ = nullptr;
}
inline const ::motors::BallhandlerAngles& Publish::ballhandler_angle_setpoints() const {
  const ::motors::BallhandlerAngles* p = ballhandler_angle_setpoints_;
  // @@protoc_insertion_point(field_get:motors.Publish.ballhandler_angle_setpoints)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::BallhandlerAngles*>(
      &::motors::_BallhandlerAngles_default_instance_);
}
inline ::motors::BallhandlerAngles* Publish::release_ballhandler_angle_setpoints() {
  // @@protoc_insertion_point(field_release:motors.Publish.ballhandler_angle_setpoints)
  
  ::motors::BallhandlerAngles* temp = ballhandler_angle_setpoints_;
  ballhandler_angle_setpoints_ = nullptr;
  return temp;
}
inline ::motors::BallhandlerAngles* Publish::mutable_ballhandler_angle_setpoints() {
  
  if (ballhandler_angle_setpoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::BallhandlerAngles>(GetArenaNoVirtual());
    ballhandler_angle_setpoints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.ballhandler_angle_setpoints)
  return ballhandler_angle_setpoints_;
}
inline void Publish::set_allocated_ballhandler_angle_setpoints(::motors::BallhandlerAngles* ballhandler_angle_setpoints) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ballhandler_angle_setpoints_;
  }
  if (ballhandler_angle_setpoints) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ballhandler_angle_setpoints = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ballhandler_angle_setpoints, submessage_arena);
    }
    
  } else {
    
  }
  ballhandler_angle_setpoints_ = ballhandler_angle_setpoints;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.ballhandler_angle_setpoints)
}

// .motors.Status drive_motors_enabled = 4;
inline bool Publish::has_drive_motors_enabled() const {
  return this != internal_default_instance() && drive_motors_enabled_ != nullptr;
}
inline void Publish::clear_drive_motors_enabled() {
  if (GetArenaNoVirtual() == nullptr && drive_motors_enabled_ != nullptr) {
    delete drive_motors_enabled_;
  }
  drive_motors_enabled_ = nullptr;
}
inline const ::motors::Status& Publish::drive_motors_enabled() const {
  const ::motors::Status* p = drive_motors_enabled_;
  // @@protoc_insertion_point(field_get:motors.Publish.drive_motors_enabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::Status*>(
      &::motors::_Status_default_instance_);
}
inline ::motors::Status* Publish::release_drive_motors_enabled() {
  // @@protoc_insertion_point(field_release:motors.Publish.drive_motors_enabled)
  
  ::motors::Status* temp = drive_motors_enabled_;
  drive_motors_enabled_ = nullptr;
  return temp;
}
inline ::motors::Status* Publish::mutable_drive_motors_enabled() {
  
  if (drive_motors_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::Status>(GetArenaNoVirtual());
    drive_motors_enabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.drive_motors_enabled)
  return drive_motors_enabled_;
}
inline void Publish::set_allocated_drive_motors_enabled(::motors::Status* drive_motors_enabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete drive_motors_enabled_;
  }
  if (drive_motors_enabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      drive_motors_enabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, drive_motors_enabled, submessage_arena);
    }
    
  } else {
    
  }
  drive_motors_enabled_ = drive_motors_enabled;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.drive_motors_enabled)
}

// .motors.RobotVector robot_velocity = 5;
inline bool Publish::has_robot_velocity() const {
  return this != internal_default_instance() && robot_velocity_ != nullptr;
}
inline void Publish::clear_robot_velocity() {
  if (GetArenaNoVirtual() == nullptr && robot_velocity_ != nullptr) {
    delete robot_velocity_;
  }
  robot_velocity_ = nullptr;
}
inline const ::motors::RobotVector& Publish::robot_velocity() const {
  const ::motors::RobotVector* p = robot_velocity_;
  // @@protoc_insertion_point(field_get:motors.Publish.robot_velocity)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::RobotVector*>(
      &::motors::_RobotVector_default_instance_);
}
inline ::motors::RobotVector* Publish::release_robot_velocity() {
  // @@protoc_insertion_point(field_release:motors.Publish.robot_velocity)
  
  ::motors::RobotVector* temp = robot_velocity_;
  robot_velocity_ = nullptr;
  return temp;
}
inline ::motors::RobotVector* Publish::mutable_robot_velocity() {
  
  if (robot_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::RobotVector>(GetArenaNoVirtual());
    robot_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.robot_velocity)
  return robot_velocity_;
}
inline void Publish::set_allocated_robot_velocity(::motors::RobotVector* robot_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete robot_velocity_;
  }
  if (robot_velocity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      robot_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_velocity, submessage_arena);
    }
    
  } else {
    
  }
  robot_velocity_ = robot_velocity;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.robot_velocity)
}

// .motors.RobotVector robot_position = 6;
inline bool Publish::has_robot_position() const {
  return this != internal_default_instance() && robot_position_ != nullptr;
}
inline void Publish::clear_robot_position() {
  if (GetArenaNoVirtual() == nullptr && robot_position_ != nullptr) {
    delete robot_position_;
  }
  robot_position_ = nullptr;
}
inline const ::motors::RobotVector& Publish::robot_position() const {
  const ::motors::RobotVector* p = robot_position_;
  // @@protoc_insertion_point(field_get:motors.Publish.robot_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::RobotVector*>(
      &::motors::_RobotVector_default_instance_);
}
inline ::motors::RobotVector* Publish::release_robot_position() {
  // @@protoc_insertion_point(field_release:motors.Publish.robot_position)
  
  ::motors::RobotVector* temp = robot_position_;
  robot_position_ = nullptr;
  return temp;
}
inline ::motors::RobotVector* Publish::mutable_robot_position() {
  
  if (robot_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::RobotVector>(GetArenaNoVirtual());
    robot_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.robot_position)
  return robot_position_;
}
inline void Publish::set_allocated_robot_position(::motors::RobotVector* robot_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete robot_position_;
  }
  if (robot_position) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      robot_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_position, submessage_arena);
    }
    
  } else {
    
  }
  robot_position_ = robot_position;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.robot_position)
}

// .motors.RobotVector robot_velocity_setpoint = 7;
inline bool Publish::has_robot_velocity_setpoint() const {
  return this != internal_default_instance() && robot_velocity_setpoint_ != nullptr;
}
inline void Publish::clear_robot_velocity_setpoint() {
  if (GetArenaNoVirtual() == nullptr && robot_velocity_setpoint_ != nullptr) {
    delete robot_velocity_setpoint_;
  }
  robot_velocity_setpoint_ = nullptr;
}
inline const ::motors::RobotVector& Publish::robot_velocity_setpoint() const {
  const ::motors::RobotVector* p = robot_velocity_setpoint_;
  // @@protoc_insertion_point(field_get:motors.Publish.robot_velocity_setpoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::RobotVector*>(
      &::motors::_RobotVector_default_instance_);
}
inline ::motors::RobotVector* Publish::release_robot_velocity_setpoint() {
  // @@protoc_insertion_point(field_release:motors.Publish.robot_velocity_setpoint)
  
  ::motors::RobotVector* temp = robot_velocity_setpoint_;
  robot_velocity_setpoint_ = nullptr;
  return temp;
}
inline ::motors::RobotVector* Publish::mutable_robot_velocity_setpoint() {
  
  if (robot_velocity_setpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::RobotVector>(GetArenaNoVirtual());
    robot_velocity_setpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.robot_velocity_setpoint)
  return robot_velocity_setpoint_;
}
inline void Publish::set_allocated_robot_velocity_setpoint(::motors::RobotVector* robot_velocity_setpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete robot_velocity_setpoint_;
  }
  if (robot_velocity_setpoint) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      robot_velocity_setpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_velocity_setpoint, submessage_arena);
    }
    
  } else {
    
  }
  robot_velocity_setpoint_ = robot_velocity_setpoint;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.robot_velocity_setpoint)
}

// .motors.Status software_on = 8;
inline bool Publish::has_software_on() const {
  return this != internal_default_instance() && software_on_ != nullptr;
}
inline void Publish::clear_software_on() {
  if (GetArenaNoVirtual() == nullptr && software_on_ != nullptr) {
    delete software_on_;
  }
  software_on_ = nullptr;
}
inline const ::motors::Status& Publish::software_on() const {
  const ::motors::Status* p = software_on_;
  // @@protoc_insertion_point(field_get:motors.Publish.software_on)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::Status*>(
      &::motors::_Status_default_instance_);
}
inline ::motors::Status* Publish::release_software_on() {
  // @@protoc_insertion_point(field_release:motors.Publish.software_on)
  
  ::motors::Status* temp = software_on_;
  software_on_ = nullptr;
  return temp;
}
inline ::motors::Status* Publish::mutable_software_on() {
  
  if (software_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::Status>(GetArenaNoVirtual());
    software_on_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.software_on)
  return software_on_;
}
inline void Publish::set_allocated_software_on(::motors::Status* software_on) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete software_on_;
  }
  if (software_on) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      software_on = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, software_on, submessage_arena);
    }
    
  } else {
    
  }
  software_on_ = software_on;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.software_on)
}

// .motors.Status inplay = 9;
inline bool Publish::has_inplay() const {
  return this != internal_default_instance() && inplay_ != nullptr;
}
inline void Publish::clear_inplay() {
  if (GetArenaNoVirtual() == nullptr && inplay_ != nullptr) {
    delete inplay_;
  }
  inplay_ = nullptr;
}
inline const ::motors::Status& Publish::inplay() const {
  const ::motors::Status* p = inplay_;
  // @@protoc_insertion_point(field_get:motors.Publish.inplay)
  return p != nullptr ? *p : *reinterpret_cast<const ::motors::Status*>(
      &::motors::_Status_default_instance_);
}
inline ::motors::Status* Publish::release_inplay() {
  // @@protoc_insertion_point(field_release:motors.Publish.inplay)
  
  ::motors::Status* temp = inplay_;
  inplay_ = nullptr;
  return temp;
}
inline ::motors::Status* Publish::mutable_inplay() {
  
  if (inplay_ == nullptr) {
    auto* p = CreateMaybeMessage<::motors::Status>(GetArenaNoVirtual());
    inplay_ = p;
  }
  // @@protoc_insertion_point(field_mutable:motors.Publish.inplay)
  return inplay_;
}
inline void Publish::set_allocated_inplay(::motors::Status* inplay) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete inplay_;
  }
  if (inplay) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inplay = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inplay, submessage_arena);
    }
    
  } else {
    
  }
  inplay_ = inplay;
  // @@protoc_insertion_point(field_set_allocated:motors.Publish.inplay)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace motors

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_Motors_2eproto
